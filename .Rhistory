compatible.systems = rbind(compatible.systems, com.system)
}
}
}
}
}
colnames(compatible.systems) <- c("stream", "user_interface", "collection_storage", "conveyance",
"treatment", "reuse_disposal", "mode")
as.data.frame(compatible.systems)
}
## =================================
## 3) create a matrice listing all compatible options for the stream
comp.systems.urine = get.compatible.options(urine.comp.mat.list)
strong.comp.systems.urine = comp.systems.urine[which(comp.systems.urine$mode=="strong"),]
weak.comp.systems.urine = comp.systems.urine[which(comp.systems.urine$mode=="weak"),]
comp.systems.feces = get.compatible.options(feces.comp.mat.list)
strong.comp.systems.feces = comp.systems.feces[which(comp.systems.feces$mode=="strong"),]
weak.comp.systems.feces = comp.systems.feces[which(comp.systems.feces$mode=="weak"),]
comp.systems.wet = get.compatible.options(wet.comp.mat.list)
strong.comp.systems.wet = comp.systems.wet[which(comp.systems.wet$mode=="strong"),]
weak.comp.systems.wet = comp.systems.wet[which(comp.systems.wet$mode=="weak"),]
View(strong.comp.systems.feces)
View(strong.comp.systems.urine)
View(strong.comp.systems.wet)
View(weak.comp.systems.feces)
View(comp.systems.wet)
View(comp.systems.wet)
rm(list=ls())
## =================================
## TO DOS
# -implement test at the end (multiply matrices)
# - implement stream type in matrix
## =================================
## 1) Import the matrix for one stream
## set path where the csv-files with the compatibility matrices are stored:
setwd("/Users/dorotheespuhler/Dropbox\ (Personal)/PHD\ Dropbox/1\ MODELLING/R/Compatibility_DS/")
## Note: unlike in MS Windows directories must be separated by "/" and not with "\".
# ONLY works without ', 1)'
comp.mat.urine <- read.table('comp_urine3.csv', header = TRUE, sep=',',quote = "\"'", dec = ".", row.names=1)
comp.mat.feces <- read.table('comp_feces2.csv', header = TRUE, sep=',',quote = "\"'", dec = ".", row.names=1)
comp.mat.wet <- read.table('comp_wet2.csv', header = TRUE, sep=',',quote = "\"'", dec = ".", row.names=1)
## =================================
## 2) create a list with submatrices
process.mat <- function(M, process.in, process.out) {
M.process <- M[grep(process.in, rownames(M)), grep(process.out, colnames(M))]
return(M.process)
}
process.mat.list <- function (M) {
UU <- process.mat(M,"user_interface","user_interface")
US <- process.mat(M,"user_interface","collection_storage")
SC <- process.mat(M,"collection_storage", "conveyance")
CT <- process.mat(M, "conveyance", "treatment")
TD <- process.mat(M, "treatment", "reuse_disposal")
M.list <- list(UU=UU, US=US, SC=SC, CT=CT, TD=TD)
M.list
}
urine.comp.mat.list <- process.mat.list(comp.mat.urine)
feces.comp.mat.list <- process.mat.list(comp.mat.feces)
wet.comp.mat.list <- process.mat.list(comp.mat.wet)
## =================================
## 3) define function to identify compatible systems
get.compatible.options <- function(comp.mat.list) {
compatible.systems <-  matrix(NA, ncol=7, nrow=0)
##function in function to return the names of compatible options
compatible <- function(M,n) {
comp.systems <- colnames(M)[M[n,]!=0& !is.na(M[n,])]
return(comp.systems)
}
for (s in rownames(comp.mat.list$US)) {
s.comp<- compatible(comp.mat.list$US,s)
for (c in s.comp) {
c.comp <- compatible(comp.mat.list$SC,c)
for (t in c.comp) {
t.comp <- compatible(comp.mat.list$CT,t)
for (d in t.comp) {
d.comp <- compatible(comp.mat.list$TD, d)
for (e in d.comp) {
if ( comp.mat.list$US[s,c]==0.5   | comp.mat.list$SC[c,t]==0.5  |
comp.mat.list$CT[t,d]==0.5 | comp.mat.list$TD[d,e]==0.5 ) {f<-"weak"}
else {f<-"strong"}
a <- "unknown"
#      if (grep("urine",deparse(substitute(comp.mat.list)))) {a<-"urine"}
#    if (grep("feces",deparse(substitute(comp.mat.list)))) {a<-"feces"}
#     if (grep("wet",deparse(substitute(comp.mat.list)))) {a<-"wet"}
com.system <- c(a, s, c, t, d, e, f)
compatible.systems = rbind(compatible.systems, com.system)
}
}
}
}
}
colnames(compatible.systems) <- c("stream", "user_interface", "collection_storage", "conveyance",
"treatment", "reuse_disposal", "mode")
as.data.frame(compatible.systems)
}
## =================================
## 3) create a matrice listing all compatible options for the stream
comp.systems.urine = get.compatible.options(urine.comp.mat.list)
strong.comp.systems.urine = comp.systems.urine[which(comp.systems.urine$mode=="strong"),]
weak.comp.systems.urine = comp.systems.urine[which(comp.systems.urine$mode=="weak"),]
comp.systems.feces = get.compatible.options(feces.comp.mat.list)
strong.comp.systems.feces = comp.systems.feces[which(comp.systems.feces$mode=="strong"),]
weak.comp.systems.feces = comp.systems.feces[which(comp.systems.feces$mode=="weak"),]
comp.systems.wet = get.compatible.options(wet.comp.mat.list)
strong.comp.systems.wet = comp.systems.wet[which(comp.systems.wet$mode=="strong"),]
weak.comp.systems.wet = comp.systems.wet[which(comp.systems.wet$mode=="weak"),]
## =================================
## 5) Print results
## Calculate the number of potentially possible systems
n.max <- ncol(urine.comp.mat.list$UU) * ncol(urine.comp.mat.list$US) * ncol(urine.comp.mat.list$SC) * ncol(urine.comp.mat.list$CT) * ncol(urine.comp.mat.list$TD) * ncol(feces.comp.mat.list$UU)*ncol(feces.comp.mat.list$US)*ncol(feces.comp.mat.list$SC)*ncol(feces.comp.mat.list$CT)*ncol(feces.comp.mat.list$TD)* ncol(wet.comp.mat.list$UU)*ncol(wet.comp.mat.list$US)*ncol(wet.comp.mat.list$SC) *ncol(wet.comp.mat.list$CT)*ncol(wet.comp.mat.list$TD)
cat("Maximal number of potential systems:", n.max, ".")
n.urine.max <- ncol(urine.comp.mat.list$UU) * ncol(urine.comp.mat.list$US) * ncol(urine.comp.mat.list$SC) * ncol(urine.comp.mat.list$CT) * ncol(urine.comp.mat.list$TD)
cat("Maximal number of potential systems if everything is compatible for urine:", n.urine.max, ".")
n.feces.max <- ncol(feces.comp.mat.list$UU)*ncol(feces.comp.mat.list$US)*ncol(feces.comp.mat.list$SC)*ncol(feces.comp.mat.list$CT)*ncol(feces.comp.mat.list$TD)
cat("Maximal number of potential systems if everything is compatible for feces:", n.feces.max, ".")
n.wet.max <- ncol(wet.comp.mat.list$UU)*ncol(wet.comp.mat.list$US)*ncol(wet.comp.mat.list$SC) *ncol(wet.comp.mat.list$CT)*ncol(wet.comp.mat.list$TD)
cat("Maximal number of potential systems if everything is compatible for wet:", n.wet.max, ".")
## Calculate the number of comppatible
cat("Total compatible systems for urine:", nrow(comp.systems.urine), ".")
cat("Strong compatible systems for urine:", nrow(strong.comp.systems.urine), ".")
cat("Weak compatible systems for urine:", nrow(weak.comp.systems.urine), ".")
cat("Total compatible systems for feces:", nrow(comp.systems.feces), ".")
cat("Strong compatible systems for feces:", nrow(strong.comp.systems.feces), ".")
cat("Weak compatible systems for feces:", nrow(weak.comp.systems.feces), ".")
cat("Total compatible systems for wet:", nrow(comp.systems.wet), ".")
cat("Strong compatible systems for wet:", nrow(strong.comp.systems.wet), ".")
cat("Weak compatible systems for wet:", nrow(weak.comp.systems.wet), ".")
## cross-check if the number of compatible options is matching the predicted number
comp.mat.urine.test<-comp.mat.urine
comp.mat.urine.test[is.na(comp.mat.urine)]<- 0
comp.mat.feces.test<-comp.mat.feces
comp.mat.feces.test[is.na(comp.mat.feces)]<- 0
comp.mat.wet.test<-comp.mat.wet
comp.mat.wet.test[is.na(comp.mat.wet)]<- 0
urine.comp.mat.list.test <- process.mat.list(comp.mat.urine.test)
feces.comp.mat.test <- process.mat.list(comp.mat.feces.test)
wet.comp.mat.test <- process.mat.list(comp.mat.wet.test)
#n.max.comp.urine.test <- urine.comp.mat.list.test$UU %*%  urine.comp.mat.list.test$US* urine.comp.mat.list.test$SC %*%  urine.comp.mat.list.test$CT %*%  urine.comp.mat.list.test$TD
#n.max.comp.feces.test <-   feces.comp.mat.list.test$UU %*% feces.comp.mat.list.test$US %*% feces.comp.mat.list.test$SC %*% feces.comp.mat.list.test$CT %*% feces.comp.mat.list.test$TD
#n.max.comp.wet.test <-   wet.comp.mat.list.test$UU %*%  wet.comp.mat.list.test$US %*%  wet.comp.mat.list.test$SC %*%  wet.comp.mat.list.test$CT %*%  wet.comp.mat.list.test$TD
#n.max.comp.test <- sum(n.max.comp.urine)+sum(n.max.comp.urine)+sum(n.max.comp.urine)
#cat("Maximal number of compatible systems:", n.max.comp, "\n.")
rm(list=ls())
## ==============================================================================================
#TO DOS:
#- Correct that $tech.app.score is not 1 if tech does not exist... make example...
#- run even if function not known...
#- provide tech options
#- provide functional group options
#- provide product options
#- how to get all the tech.app.scores... e.g. applist_test[[]]$tech.app.score
## ==============================================================================================
setwd("/Users/dorotheespuhler/Dropbox\ (Personal)/PHD\ Dropbox/1\ MODELLING/R/Appropriateness/")
#command: cd Dropbox/PHD\ Dropbox/1\ MODELLING/R/Appropriateness
library(gridExtra)
library(ColorPalette)
# Load required library packages
library(triangle) # extra package for triangular distribution
library (trapezoid) # extra package for trapezoidial distribution
library(rlist)  # extra package to manupulate/filter app list
# Load required functions
source("listread.r") # reads the csv data files for technologies and cases descriptions
source("req.functions.r") # contains functions that are not provided in R such as ranges
source("compute.app.r") # functions(tech, case,lshowplot=FALSE) returning app.profile and app.score
source("compute.applist.r") # function(techlist, caselist, listsep=" ", filename="") making all the app profiles for a techlist and applist
source("applist.write.r") # function(applist, listsep=" ", filename="") writes applist
## ==============================================================================================
# Create the list of technology appropriateness functions and the list of case appropriateness functions
#-------------------------------------------
# Some guidelines to fill in the data files:
#------------------------------------------
# Each data files contines a list of items (either techs or cases in the columns)
# Each items has some attributes (lines)
# The first attributes are just information, that helps to understand the case or is needed for later on
# Then the appropriateness attributes are listed
# Each attribute goes over three lines:
# 1 Name of the attributes to be used: bod, water, temp, omskil, etc.
# 2 Name of function of function (see below) describing the technology/case requirement/capactiy
# 3 Parameters required for this function
# Recommended functions are:
# req.range(x, lower=-Inf, upper=Inf)
# req.trapez(x, a, b, c, d),
# dtriangle(x, a, b, c)
# dtrapezoid(x, min, mode1, mode2, max )
# dunif(x, min, max)
# dnorm, dlnorm, dbeta, dweibull, dgamma, dlogis, etc.
# read the normal data files
caselist<- build.list("casedata.csv",2)
techlist<- build.list("techdata.csv",3)
## ==============================================================================================
# Compute appropriateness profiles (app.profile(tech, case)) and apppropriateness scores (app.scores(tech, case))
# For single examples: a pair of (caselist$case, techlist$tech)
cat("====== Using compute.app ================= \n")
# Create empty list
applist1=list()
# Compute examples
app.item.tmp <- compute.app(caselist$arbaminch, techlist$septic.tank,lshowplot = TRUE)
applist1=append(applist1,list(app.item.tmp))
app.item.tmp <- compute.app(caselist$thimi, techlist$septic.tank,lshowplot = TRUE)
applist1=append(applist1,list(app.item.tmp))
app.item.tmp <- compute.app(caselist$arbaminch, techlist$single.pit, lshowplot = TRUE)
applist1=append(applist1,list(app.item.tmp))
app.item.tmp <- compute.app(caselist$arbaminch, techlist$double.pit, lshowplot = TRUE)
applist1=append(applist1,list(app.item.tmp))
# Print examples
print(t(app.item.tmp), digits=4)  #optionally app.septic.tank[1:3] for tech, case, score, can't print the tech.app.profile as it is list in list
# For enitre applists and techlists: a pair of (caselist, techlist)
cat("====== Using compute.applist ================= \n")
applist2<-compute.applist(caselist,techlist,lsort=TRUE)
#applist_daniel<-compute.applist(caselist_daniel,techlist_daniel,lsort=TRUE)
## ==============================================================================================
# Applist displays
# Write to screen
applist.write(applist2)
# Write to file
applist.write(applist2, listsep=";", filename="app_list2.csv")
## ==============================================================================================
# Use rlist to filter
applist<-applist2
# Example only arbaminch
sub.applist=list.filter(applist,case=="arbaminch")
cat("====================== \n")
cat("Only arbaminch  \n")
applist.write(sub.applist)
# Example only arbaminch and score > 0
sub.applist=list.filter(applist,case=="arbaminch", tech.app.score>0)
cat("====================== \n")
cat("Only arbaminch and score > 0 \n")
applist.write(sub.applist)
# Examples of manipulations
sub.applist=list.filter(applist,case=="arbaminch", tech=="single.pit")
sub.applist[[1]]$tech.app.profile$bod
# using $ instead of list.filter
applist[[1]]$tech.app.profile$bod # to get the bod of an item in the list, 1 ist the list id
## ==============================================================================================
# Test data from Daniel
# Read data
caselist_daniel<- build.list("casedata_daniel.csv",2)
techlist_daniel<- build.list("techdata_daniel.csv",3)
# Test one by one
compute.app(caselist_daniel$arbaminch,techlist_daniel$pour.flush, lshowplot=TRUE)
compute.app(caselist_daniel$arbaminch,techlist_daniel$UDDT, lshowplot=TRUE)
compute.app(caselist_daniel$arbaminch,techlist_daniel$septic.tank, lshowplot=TRUE)
compute.app(caselist_daniel$arbaminch,techlist_daniel$single.pit, lshowplot=TRUE)
compute.app(caselist_daniel$arbaminch,techlist_daniel$wsp, lshowplot=TRUE)
compute.app(caselist_daniel$arbaminch,techlist_daniel$surface.flow.CW, lshowplot=TRUE)
# Compute entire list
applist_daniel<-compute.applist(caselist_daniel,techlist_daniel,lsort=TRUE)
# Write to screen
applist.write(applist_daniel)
# Write to file
applist.write(applist_daniel, listsep=";", filename="applist_daniel.csv")
## ==============================================================================================
# Testing data
# Read data
caselist_test<- build.list("casedata_test.csv",2)
techlist_test<- build.list("techdata_test.csv",3)
# Test one by one
compute.app(caselist_test$arbaminch,techlist_test$pour.flush, lshowplot=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$UDDT, lshowplot=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$septic.tank, lshowplot=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$single.pit, lshowplot=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$wsp, lshowplot=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$surface.flow.CW, lshowplot=TRUE)
# Compute entire list
applist_test<-compute.applist(caselist_test,techlist_test,lsort=TRUE)
# Write to screen
applist.write(applist_test)
# Write to file
applist.write(applist_test, listsep=";", filename="applist_test.csv")
## ==============================================================================================
# Testing data
# Read data
caselist_test<- build.list("casedata_test.csv",2)
techlist_test<- build.list("techdata_test.csv",3)
# Test one by one
compute.app(caselist_test$arbaminch,techlist_test$pour.flush, lshowplot=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$UDDT, lshowplot=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$septic.tank, lshowplot=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$single.pit, lshowplot=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$wsp, lshowplot=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$surface.flow.CW, lshowplot=TRUE)
# Compute entire list
applist_test<-compute.applist(caselist_test,techlist_test,lsort=TRUE)
# Write to screen
applist.write(applist_test)
# Write to file
applist.write(applist_test, listsep=";", filename="applist_test.csv")
rm(list=ls())
## ==============================================================================================
#TO DOS:
#- Correct that $tech.app.score is not 1 if tech does not exist... make example...
#- run even if function not known in casedata...
#- how to get all the tech.app.scores... e.g. applist_test[[]]$tech.app.score
#- how to make yes/no or a/b functions
#- how to make functions more flexibel, e.g. 25, 50, 75%
#- provide tech options
## ==============================================================================================
setwd("/Users/dorotheespuhler/Dropbox\ (Personal)/PHD\ Dropbox/1\ MODELLING/R/Appropriateness/")
#command: cd Dropbox/PHD\ Dropbox/1\ MODELLING/R/Appropriateness
library(gridExtra)
library(ColorPalette)
# Load required library packages
library(triangle) # extra package for triangular distribution
library (trapezoid) # extra package for trapezoidial distribution
library(rlist)  # extra package to manupulate/filter app list
# Load required functions
source("listread.r") # reads the csv data files for technologies and cases descriptions
source("req.functions.r") # contains functions that are not provided in R such as ranges
source("compute.app.r") # functions(tech, case,lshowplot=FALSE) returning app.profile and app.score
source("compute.applist.r") # function(techlist, caselist, listsep=" ", filename="") making all the app profiles for a techlist and applist
source("applist.write.r") # function(applist, listsep=" ", filename="") writes applist
## ==============================================================================================
# Test data from Daniel
# Read data
caselist_daniel<- build.list("casedata_daniel.csv",2)
techlist_daniel<- build.list("techdata_daniel.csv",3)
# Test one by one
compute.app(caselist_daniel$arbaminch,techlist_daniel$pour.flush, lshowplot=TRUE)
compute.app(caselist_daniel$arbaminch,techlist_daniel$UDDT, lshowplot=TRUE)
compute.app(caselist_daniel$arbaminch,techlist_daniel$septic.tank, lshowplot=TRUE)
compute.app(caselist_daniel$arbaminch,techlist_daniel$single.pit, lshowplot=TRUE)
compute.app(caselist_daniel$arbaminch,techlist_daniel$wsp, lshowplot=TRUE)
compute.app(caselist_daniel$arbaminch,techlist_daniel$surface.flow.CW, lshowplot=TRUE)
# Compute entire list
applist_daniel<-compute.applist(caselist_daniel,techlist_daniel,lsort=TRUE)
# Write to screen
applist.write(applist_daniel)
# Write to file
applist.write(applist_daniel, listsep=";", filename="applist_daniel.csv")
compute.app(caselist_daniel$arbaminch,techlist_daniel$pour.flush, lshowplot=TRUE)
compute.app(caselist_daniel$arbaminch,techlist_daniel$UDDT, lshowplot=TRUE)
caselist_daniel<- build.list("casedata_daniel.csv",2)
techlist_daniel<- build.list("techdata_daniel.csv",3)
compute.app(caselist_daniel$arbaminch,techlist_daniel$pour.flush, lshowplot=TRUE)
compute.app(caselist_daniel$arbaminch,techlist_daniel$UDDT, lshowplot=TRUE)
x=c(0:5)
x
req.trapez(x, a=0, b=1, c=2, d=3),
req.trapez(x, a=0, b=1, c=2, d=3)
# Create the list of technology appropriateness functions and the list of case appropriateness functions
caselist<- build.list("casedata.csv",2)
techlist<- build.list("techdata.csv",3)
at("====== Using compute.app ================= \n")
# Create empty list
applist1=list()
# Compute examples
app.item.tmp <- compute.app(caselist$arbaminch, techlist$septic.tank,lshowplot = TRUE)
applist1=append(applist1,list(app.item.tmp))
app.item.tmp <- compute.app(caselist$thimi, techlist$septic.tank,lshowplot = TRUE)
applist1=append(applist1,list(app.item.tmp))
app.item.tmp <- compute.app(caselist$arbaminch, techlist$single.pit, lshowplot = TRUE)
applist1=append(applist1,list(app.item.tmp))
app.item.tmp <- compute.app(caselist$arbaminch, techlist$double.pit, lshowplot = TRUE)
applist1=append(applist1,list(app.item.tmp))
# Print examples
print(t(app.item.tmp), digits=4)  #optionally app.septic.tank[1:3] for tech, case, score, can't print the tech.app.profile as it is list in list
app.item.tmp <- compute.app(caselist$thimi, techlist$septic.tank,lshowplot = TRUE)
app.item.tmp <- compute.app(caselist$arbaminch, techlist$septic.tank,lshowplot = TRUE)
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
rm(list=ls())
## ==============================================================================================
#TO DOS:
#- Correct that $tech.app.score is not 1 if tech does not exist... make example...
#- run even if function not known in casedata...
#- how to get all the tech.app.scores... e.g. applist_test[[]]$tech.app.score
#- how to make yes/no or a/b functions
#- how to make functions more flexibel, e.g. 25, 50, 75%
#- provide tech options
## ==============================================================================================
setwd("/Users/dorotheespuhler/Dropbox\ (Personal)/PHD\ Dropbox/1\ MODELLING/R/Appropriateness/")
#command: cd Dropbox/PHD\ Dropbox/1\ MODELLING/R/Appropriateness
library(gridExtra)
library(ColorPalette)
# Load required library packages
library(triangle) # extra package for triangular distribution
library (trapezoid) # extra package for trapezoidial distribution
library(rlist)  # extra package to manupulate/filter app list
# Load required functions
source("listread.r") # reads the csv data files for technologies and cases descriptions
source("req.functions.r") # contains functions that are not provided in R such as ranges
source("compute.app.r") # functions(tech, case,lshowplot=FALSE) returning app.profile and app.score
source("compute.applist.r") # function(techlist, caselist, listsep=" ", filename="") making all the app profiles for a techlist and applist
source("applist.write.r") # function(applist, listsep=" ", filename="") writes applist
# Read data
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
# Test one by one
applist_test<-compute.applist(caselist_test,techlist_test,lsort=TRUE)
applist_test<-compute.applist(caselist_test,techlist_test,lsort=TRUE)
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
applist_test<-compute.applist(caselist_test,techlist_test,lsort=TRUE)
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
applist_test<-compute.applist(caselist_test,techlist_test,lsort=TRUE)
# Read data
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
applist_test<-compute.applist(caselist_test,techlist_test,lsort=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$uddt, lshowplot=TRUE)
# Read data
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
# Test one by one
compute.app(caselist_test$arbaminch,techlist_test$uddt, lshowplot=TRUE)
# C
# Read data
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
# Test one by one
compute.app(caselist_test$arbaminch,techlist_test$uddt, lshowplot=TRUE)
# C
# Read data
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
# Test one by one
compute.app(caselist_test$arbaminch,techlist_test$uddt, lshowplot=TRUE)
# C
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
#
compute.app(caselist_test$arbaminch,techlist_test$uddt, lshowplot=TRUE)
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
# Test one by one
compute.app(caselist_test$arbaminch,techlist_test$uddt, lshowplot=TRUE)
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
# Test one by one
compute.app(caselist_test$arbaminch,techlist_test$uddt, lshowplot=TRUE)
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
# Test one by one
compute.app(caselist_test$arbaminch,techlist_test$uddt, lshowplot=TRUE)
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
# Test one by one
compute.app(caselist_test$arbaminch,techlist_test$uddt, lshowplot=TRUE)
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
# Test one by one
compute.app(caselist_test$arbaminch,techlist_test$uddt, lshowplot=TRUE)
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
compute.app(caselist_test$arbaminch,techlist_test$uddt, lshowplot=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$dry.toilet, lshowplot=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$pour.flush, lshowplot=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$urine.storagetank, lshowplot=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$dehydration.vaults, lshowplot=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$double.vip, lshowplot=TRUE)
applist_test<-compute.applist(caselist_test,techlist_test,lsort=TRUE)
applist.write(applist_test)
applist.write(applist_test, listsep=";", filename="applist_test.csv")
# Read data
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
# Test one by one
# Compute entire list
applist_test<-compute.applist(caselist_test,techlist_test,lsort=TRUE)
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
applist_test<-compute.applist(caselist_test,techlist_test,lsort=TRUE)
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
# Compute entire list
applist_test<-compute.applist(caselist_test,techlist_test,lsort=TRUE)
techops<-c(uddt,dry.toilet,pour.flush,urine.storagetank,dehydration.vaults,double.vip,septic.tank,motorized.emptying,conventional.sewer,T1.empty,T1.unplanted.dryingbed,T1.wsp,T2.empty,T2.unplanted.dryingbed,T2.wsp,application.urine,application.faeces,application.humus,application.sluldge,irrigation)
techops<-c('uddt','dry.toilet','pour.flush','urine.storagetank','dehydration.vaults','double.vip','septic.tank','motorized.emptying','conventional.sewer','T1.empty','T1.unplanted.dryingbed','T1.wsp','T2.empty','T2.unplanted.dryingbed','T2.wsp','application.urine','application.faeces','application.humus','application.sluldge','irrigation)
techops<-c('uddt','dry.toilet','pour.flush','urine.storagetank','dehydration.vaults','double.vip','septic.tank','motorized.emptying','conventional.sewer','T1.empty','T1.unplanted.dryingbed','T1.wsp','T2.empty','T2.unplanted.dryingbed','T2.wsp','application.urine','application.faeces','application.humus','application.sluldge','irrigation')
compute.app(caselist_test$arbaminch,techlist_test$uddt, lshowplot=TRUE)
techops<-c('uddt','dry.toilet','pour.flush','urine.storagetank','dehydration.vaults','double.vip','septic.tank','motorized.emptying','conventional.sewer','T1.empty','T1.unplanted.dryingbed','T1.wsp','T2.empty','T2.unplanted.dryingbed','T2.wsp','application.urine','application.faeces','application.humus','application.sluldge','irrigation')
techops
length(techops)
for(i in 1:length(techops)){
compute.app(caselist_test$arbaminch,techlist_test$techop[i], lshowplot=TRUE)
}
compute.app(caselist_test$arbaminch,techlist_test$techop[i], lshowplot=TRUE)
techops<-c('uddt','dry.toilet','pour.flush','urine.storagetank','dehydration.vaults','double.vip','septic.tank','motorized.emptying','conventional.sewer','T1.empty','T1.unplanted.dryingbed','T1.wsp','T2.empty','T2.unplanted.dryingbed','T2.wsp','application.urine','application.faeces','application.humus','application.sluldge','irrigation')
compute.app(caselist_test$arbaminch,techlist_test$techop[1], lshowplot=TRUE)
techop[1]
techops[1]
compute.app(caselist_test$arbaminch,techlist_test$techops[1], lshowplot=TRUE)
as.charachter(techops[1])
as.character(techops)
as.character(techops[1])
as.string
techops[1]
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
a<-techops[1]
caselist_test$uddt
techlist_test$uddt
techlist_test$a
techlist_test$techops[1]
# Testing data
# Read data
caselist_test<- build.list("casedata_ex.csv",2)
techlist_test<- build.list("techdata_ex.csv",3)
# Test one by one
applist_test<-compute.applist(caselist_test,techlist_test,lsort=TRUE)
applist.write(applist_test)
applist.write(applist_test, listsep=";", filename="applist_test.csv")
techops<-c('uddt','dry.toilet','pour.flush','urine.storagetank','dehydration.vaults','double.vip','septic.tank','motorized.emptying','conventional.sewer','T1.empty','T1.unplanted.dryingbed','T1.wsp','T2.empty','T2.unplanted.dryingbed','T2.wsp','application.urine','application.faeces','application.humus','application.sluldge','irrigation')
techlist_test[1]
compute.app(caselist_test$arbaminch,techlist_test[1], lshowplot=TRUE)
compute.app(caselist_test$arbaminch,techlist_test$uddt, lshowplot=TRUE)
